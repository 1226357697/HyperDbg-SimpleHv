# 第四章：调试器通信机制

## 4.1 通信架构概览

HyperDbg实现了完整的调试器通信协议，支持外部调试器（Debugger）与被调试机（Debuggee）之间的双向通信。主要通信通道是**串口（Serial Port）**。

### 4.1.1 通信模型

```
┌──────────────────────────────────┐          ┌──────────────────────────────────┐
│   外部调试器 (Debugger)           │          │   HyperDbg (Debuggee)            │
│   - Windows/Linux主机             │          │   - 被调试的Windows系统           │
│   - hyperdbg-cli 客户端           │          │   - hyperkd.sys驱动              │
└──────────────┬───────────────────┘          └──────────────┬───────────────────┘
               │                                              │
               │        1. 发送命令包（Command Packet）       │
               ├─────────────────────────────────────────────>│
               │                                              │
               │                                              ├─> SerialConnectionRecvBuffer()
               │                                              ├─> KdReceivePacketFromDebuggee()
               │                                              ├─> 解析命令类型
               │                                              ├─> 执行命令
               │                                              │
               │        2. 接收响应包（Response Packet）      │
               │<─────────────────────────────────────────────┤
               │                                              ├─> KdResponsePacketToDebugger()
               │                                              └─> SerialConnectionSendBuffer()
               │
               ↓
        显示结果给用户
```

### 4.1.2 通信通道

HyperDbg支持多种通信方式：

| 通信方式 | 使用场景 | 优势 | 劣势 |
|---------|---------|------|------|
| **串口（COM Port）** | 物理机调试 | 稳定、可靠、低级 | 速度慢（115200 bps） |
| **命名管道（NamedPipe）** | 虚拟机调试 | 速度快 | 仅虚拟机可用 |
| **网络（TCP/IP）** | 远程调试 | 灵活、远程 | 复杂性高 |

**本文主要分析串口通信机制**。

---

## 4.2 消息追踪回调（Message Tracing Callbacks）

### 4.2.1 回调结构定义

**文件位置**：`hyperdbg/include/SDK/modules/VMM.h`

```c
/**
 * @brief 消息追踪回调结构
 */
typedef struct _MESSAGE_TRACING_CALLBACKS {

    /**
     * @brief 检查VMX操作状态
     * @details 确定当前是在VMX root还是non-root模式
     */
    VMX_OPERATION_CHECK VmxOperationCheck;

    /**
     * @brief 检查是否应该立即发送消息
     * @details 某些情况（如断点命中）需要立即发送，不能缓冲
     */
    CHECK_IMMEDIATE_MESSAGE_SENDING CheckImmediateMessageSending;

    /**
     * @brief 发送立即消息到调试器
     * @details 绕过缓冲区，直接通过串口发送
     */
    SEND_IMMEDIATE_MESSAGE SendImmediateMessage;

} MESSAGE_TRACING_CALLBACKS, *PMESSAGE_TRACING_CALLBACKS;

// ============================================
// 回调函数类型定义
// ============================================

/**
 * @brief 检查VMX模式
 * @return BOOLEAN TRUE=VMX root, FALSE=VMX non-root
 */
typedef BOOLEAN (*VMX_OPERATION_CHECK)();

/**
 * @brief 检查立即消息机制
 * @return BOOLEAN TRUE=应该立即发送，FALSE=可以缓冲
 */
typedef BOOLEAN (*CHECK_IMMEDIATE_MESSAGE_SENDING)(
    UINT32 OperationCode
);

/**
 * @brief 发送立即消息
 */
typedef BOOLEAN (*SEND_IMMEDIATE_MESSAGE)(
    CHAR *  OptionalBuffer,
    UINT32  OptionalBufferLength,
    UINT32  OperationCode
);
```

### 4.2.2 回调初始化

**文件位置**：`hyperdbg/hyperkd/code/driver/Loader.c`

```c
BOOLEAN LoaderInitVmmAndDebugger() {
    MESSAGE_TRACING_CALLBACKS MsgTracingCallbacks = {0};

    //
    // ========================================
    // 填充消息追踪回调
    // ========================================
    //

    /**
     * @brief 检查VMX状态
     * @details 返回当前核心是否在VMX root模式
     */
    MsgTracingCallbacks.VmxOperationCheck =
        VmFuncVmxGetCurrentExecutionMode;

    /**
     * @brief 检查是否应该立即发送消息
     * @details 某些操作码需要立即发送：
     *          - 断点命中
     *          - 错误消息
     *          - 调试器paused状态
     */
    MsgTracingCallbacks.CheckImmediateMessageSending =
        KdCheckImmediateMessagingMechanism;

    /**
     * @brief 发送立即消息到调试器
     * @details 通过串口直接发送，不经过缓冲区
     */
    MsgTracingCallbacks.SendImmediateMessage =
        KdLoggingResponsePacketToDebugger;

    //
    // ========================================
    // 初始化消息追踪模块
    // ========================================
    //
    if (LogInitialize(&MsgTracingCallbacks)) {
        // 成功
    }
}
```

### 4.2.3 立即消息机制

```c
/**
 * @brief 检查是否应该立即发送消息
 */
BOOLEAN KdCheckImmediateMessagingMechanism(UINT32 OperationCode) {

    // 检查操作码是否需要立即发送
    switch (OperationCode) {

        // 调试器命中断点/paused
        case OPERATION_DEBUGGEE_PAUSED_AND_CURRENT_INSTRUCTION:
        case OPERATION_BREAKPOINT_HIT:
            return TRUE;

        // 错误消息
        case OPERATION_LOG_ERROR_MESSAGE:
        case OPERATION_LOG_CRITICAL_MESSAGE:
            return TRUE;

        // 命令执行完成
        case OPERATION_COMMAND_FINISHED:
            return TRUE;

        // 其他消息可以缓冲
        default:
            return FALSE;
    }
}

/**
 * @brief 发送立即消息到调试器
 */
BOOLEAN KdLoggingResponsePacketToDebugger(
    CHAR *  OptionalBuffer,
    UINT32  OptionalBufferLength,
    UINT32  OperationCode
) {
    // 构建数据包
    DEBUGGER_REMOTE_PACKET Packet = {0};

    Packet.Indicator = INDICATOR_OF_HYPERDBG_PACKET;
    Packet.TypeOfThePacket = DEBUGGER_REMOTE_PACKET_TYPE_DEBUGGEE_TO_DEBUGGER;
    Packet.RequestedActionOfThePacket = OperationCodeToAction(OperationCode);

    // 立即通过串口发送（不缓冲）
    SerialConnectionSendBuffer((CHAR *)&Packet, sizeof(Packet));

    if (OptionalBuffer && OptionalBufferLength > 0) {
        SerialConnectionSendBuffer(OptionalBuffer, OptionalBufferLength);
    }

    return TRUE;
}
```

---

## 4.3 串口通信层

### 4.3.1 串口通信概述

**文件位置**：`hyperdbg/hyperkd/code/debugger/communication/SerialConnection.c`

HyperDbg使用串口作为主要通信通道，因为：
1. **可靠性高**：不依赖操作系统网络栈
2. **低级访问**：即使系统崩溃也能通信
3. **简单直接**：硬件级别的通信
4. **调试友好**：可以调试网络栈本身

### 4.3.2 数据包协议

#### 数据包结构

```c
/**
 * @brief 远程调试包结构
 */
typedef struct _DEBUGGER_REMOTE_PACKET {

    /**
     * @brief 包标识符（Magic Number）
     * @details 用于识别有效的HyperDbg包
     */
    UINT64 Indicator;  // INDICATOR_OF_HYPERDBG_PACKET = 0x4859504552444247 ("HYPERDBG")

    /**
     * @brief 包类型
     */
    UINT32 TypeOfThePacket;

    /**
     * @brief 请求的操作
     */
    UINT32 RequestedActionOfThePacket;

    // 可选的数据紧跟在这个结构后面

} DEBUGGER_REMOTE_PACKET, *PDEBUGGER_REMOTE_PACKET;

// ============================================
// 包类型定义
// ============================================
typedef enum _DEBUGGER_REMOTE_PACKET_TYPE {
    DEBUGGER_REMOTE_PACKET_TYPE_DEBUGGER_TO_DEBUGGEE,  // 调试器->被调试机
    DEBUGGER_REMOTE_PACKET_TYPE_DEBUGGEE_TO_DEBUGGER,  // 被调试机->调试器
} DEBUGGER_REMOTE_PACKET_TYPE;

// ============================================
// 请求操作定义
// ============================================
typedef enum _DEBUGGER_REMOTE_PACKET_REQUESTED_ACTION {
    // Debugger -> Debuggee
    DEBUGGER_REMOTE_PACKET_REQUESTED_ACTION_ON_VMX_ROOT_MODE_STEP,
    DEBUGGER_REMOTE_PACKET_REQUESTED_ACTION_ON_VMX_ROOT_MODE_CONTINUE,
    DEBUGGER_REMOTE_PACKET_REQUESTED_ACTION_ON_VMX_ROOT_MODE_CLOSE_AND_UNLOAD_DEBUGGEE,
    DEBUGGER_REMOTE_PACKET_REQUESTED_ACTION_ON_VMX_ROOT_READ_REGISTERS,
    DEBUGGER_REMOTE_PACKET_REQUESTED_ACTION_ON_VMX_ROOT_READ_MEMORY,
    DEBUGGER_REMOTE_PACKET_REQUESTED_ACTION_ON_VMX_ROOT_EDIT_MEMORY,
    DEBUGGER_REMOTE_PACKET_REQUESTED_ACTION_ON_VMX_ROOT_BP,          // 设置断点
    DEBUGGER_REMOTE_PACKET_REQUESTED_ACTION_ON_VMX_ROOT_LIST_OR_MODIFY_BREAKPOINTS,

    // Debuggee -> Debugger
    DEBUGGER_REMOTE_PACKET_REQUESTED_ACTION_DEBUGGEE_PAUSED_AND_CURRENT_INSTRUCTION,
    DEBUGGER_REMOTE_PACKET_REQUESTED_ACTION_DEBUGGEE_RESULT_OF_REGISTERS,
    DEBUGGER_REMOTE_PACKET_REQUESTED_ACTION_DEBUGGEE_RESULT_OF_MEMORY,
    DEBUGGER_REMOTE_PACKET_REQUESTED_ACTION_DEBUGGEE_RESULT_OF_BP,

    // ... 更多操作类型
} DEBUGGER_REMOTE_PACKET_REQUESTED_ACTION;
```

#### 包传输格式

```
串口传输格式：

┌────────────────────────────────────────────────────────┐
│  DEBUGGER_REMOTE_PACKET                                │
│  ┌──────────────────────────────────────────────────┐  │
│  │ Indicator (8 bytes)        = 0x4859504552444247  │  │
│  ├──────────────────────────────────────────────────┤  │
│  │ TypeOfThePacket (4 bytes)  = DEBUGGER_TO_DEBUGGEE│  │
│  ├──────────────────────────────────────────────────┤  │
│  │ RequestedAction (4 bytes)  = ACTION_STEP         │  │
│  └──────────────────────────────────────────────────┘  │
├────────────────────────────────────────────────────────┤
│  Optional Data (variable length)                       │
│  ┌──────────────────────────────────────────────────┐  │
│  │ Command-specific data...                         │  │
│  │ (e.g., 断点地址、内存地址等)                      │  │
│  └──────────────────────────────────────────────────┘  │
├────────────────────────────────────────────────────────┤
│  End of Buffer Marker (4 bytes)                        │
│  ┌──────────────────────────────────────────────────┐  │
│  │ 0x00, 0x11, 0x22, 0x33                           │  │
│  └──────────────────────────────────────────────────┘  │
└────────────────────────────────────────────────────────┘
```

### 4.3.3 串口发送实现

```c
/**
 * @brief 发送缓冲区到串口
 *
 * @param Buffer 要发送的数据
 * @param Length 数据长度
 * @return BOOLEAN 成功返回TRUE
 */
BOOLEAN SerialConnectionSendBuffer(CHAR * Buffer, UINT32 Length) {

    //
    // ========================================
    // 1. 发送数据
    // ========================================
    //
    for (UINT32 i = 0; i < Length; i++) {
        if (!KdHyperDbgSendByte(Buffer[i], TRUE)) {
            LogError("Failed to send byte at index %d", i);
            return FALSE;
        }
    }

    //
    // ========================================
    // 2. 发送结束标记
    // ========================================
    //
    SerialConnectionSendEndOfBuffer();

    return TRUE;
}

/**
 * @brief 发送结束标记
 */
VOID SerialConnectionSendEndOfBuffer() {
    // 发送4字节的结束标记
    KdHyperDbgSendByte(SERIAL_END_OF_BUFFER_CHAR_1, TRUE);  // 0x00
    KdHyperDbgSendByte(SERIAL_END_OF_BUFFER_CHAR_2, TRUE);  // 0x11
    KdHyperDbgSendByte(SERIAL_END_OF_BUFFER_CHAR_3, TRUE);  // 0x22
    KdHyperDbgSendByte(SERIAL_END_OF_BUFFER_CHAR_4, TRUE);  // 0x33
}

/**
 * @brief 底层串口发送单个字节
 *
 * @param Byte 要发送的字节
 * @param IsSynchronous 是否同步等待
 * @return BOOLEAN 成功返回TRUE
 */
BOOLEAN KdHyperDbgSendByte(UCHAR Byte, BOOLEAN IsSynchronous) {
    UINT32 Timeout = 0;

    if (IsSynchronous) {
        // 同步发送 - 等待发送完成

        // 等待发送寄存器空闲
        while (!SerialPortCanTransmit() && Timeout < SERIAL_TIMEOUT) {
            Timeout++;
            _mm_pause();  // 减少CPU占用
        }

        if (Timeout >= SERIAL_TIMEOUT) {
            return FALSE;
        }

        // 写入数据到串口
        __outbyte(COM_PORT + SERIAL_THR_OFFSET, Byte);

        return TRUE;
    } else {
        // 异步发送 - 直接写入（可能丢失）
        __outbyte(COM_PORT + SERIAL_THR_OFFSET, Byte);
        return TRUE;
    }
}

/**
 * @brief 检查串口是否可以发送
 */
BOOLEAN SerialPortCanTransmit() {
    // 读取Line Status Register
    UCHAR Status = __inbyte(COM_PORT + SERIAL_LSR_OFFSET);

    // 检查THR Empty位（bit 5）
    return (Status & SERIAL_LSR_THR_EMPTY) != 0;
}
```

### 4.3.4 串口接收实现

```c
/**
 * @brief 从串口接收缓冲区
 *
 * @param BufferToSave 保存接收数据的缓冲区
 * @param LengthReceived 输出：实际接收的长度
 * @return BOOLEAN 成功返回TRUE
 */
BOOLEAN SerialConnectionRecvBuffer(CHAR * BufferToSave, UINT32 * LengthReceived) {
    UINT32 Loop = 0;

    //
    // ========================================
    // 循环读取数据直到收到结束标记
    // ========================================
    //
    while (TRUE) {
        UCHAR RecvChar = NULL_ZERO;

        // 读取一个字节
        if (!KdHyperDbgRecvByte(&RecvChar)) {
            // 没有数据，继续等待
            continue;
        }

        //
        // 检查缓冲区大小限制
        //
        if (!(MaxSerialPacketSize > Loop)) {
            LogError("Received buffer exceeds maximum packet size");
            return FALSE;
        }

        // 保存字节
        BufferToSave[Loop] = RecvChar;

        //
        // 检查是否收到结束标记
        //
        if (SerialConnectionCheckForTheEndOfTheBuffer(&Loop, (BYTE *)BufferToSave)) {
            // 收到完整包
            break;
        }

        Loop++;
    }

    // 设置接收长度
    *LengthReceived = Loop;

    return TRUE;
}

/**
 * @brief 底层串口接收单个字节
 *
 * @param RecvByte 输出：接收到的字节
 * @return BOOLEAN 成功返回TRUE，无数据返回FALSE
 */
BOOLEAN KdHyperDbgRecvByte(PUCHAR RecvByte) {

    // 检查是否有数据可读
    UCHAR Status = __inbyte(COM_PORT + SERIAL_LSR_OFFSET);

    if ((Status & SERIAL_LSR_DATA_READY) == 0) {
        // 没有数据
        return FALSE;
    }

    // 读取数据
    *RecvByte = __inbyte(COM_PORT + SERIAL_RBR_OFFSET);

    return TRUE;
}

/**
 * @brief 检查是否收到结束标记
 *
 * @param CurrentLoopIndex 当前循环索引（输入/输出）
 * @param Buffer 缓冲区
 * @return BOOLEAN TRUE=收到结束标记
 */
BOOLEAN SerialConnectionCheckForTheEndOfTheBuffer(PUINT32 CurrentLoopIndex, BYTE * Buffer) {
    UINT32 ActualBufferLength = *CurrentLoopIndex;

    // 结束标记是4字节，所以至少需要4个字节
    if (*CurrentLoopIndex <= 3) {
        return FALSE;
    }

    // 检查最后4个字节是否匹配结束标记
    if (Buffer[ActualBufferLength]     == SERIAL_END_OF_BUFFER_CHAR_4 &&  // 0x33
        Buffer[ActualBufferLength - 1] == SERIAL_END_OF_BUFFER_CHAR_3 &&  // 0x22
        Buffer[ActualBufferLength - 2] == SERIAL_END_OF_BUFFER_CHAR_2 &&  // 0x11
        Buffer[ActualBufferLength - 3] == SERIAL_END_OF_BUFFER_CHAR_1) {  // 0x00

        //
        // 清除结束标记（从有效数据中移除）
        //
        Buffer[ActualBufferLength - 3] = NULL_ZERO;
        Buffer[ActualBufferLength - 2] = NULL_ZERO;
        Buffer[ActualBufferLength - 1] = NULL_ZERO;
        Buffer[ActualBufferLength]     = NULL_ZERO;

        // 更新长度（减去结束标记）
        *CurrentLoopIndex = ActualBufferLength - 3;

        return TRUE;
    }

    return FALSE;
}
```

### 4.3.5 串口配置

```c
/**
 * @brief 串口配置参数
 */
#define COM_PORT                    COM1_PORT       // 0x3F8 (COM1)
#define SERIAL_BAUD_RATE            115200          // 波特率

// 串口寄存器偏移
#define SERIAL_THR_OFFSET           0x00            // Transmit Holding Register
#define SERIAL_RBR_OFFSET           0x00            // Receive Buffer Register
#define SERIAL_LSR_OFFSET           0x05            // Line Status Register
#define SERIAL_LCR_OFFSET           0x03            // Line Control Register
#define SERIAL_MCR_OFFSET           0x04            // Modem Control Register

// Line Status Register位定义
#define SERIAL_LSR_DATA_READY       0x01            // 数据准备好
#define SERIAL_LSR_THR_EMPTY        0x20            // 发送寄存器空

// 结束标记
#define SERIAL_END_OF_BUFFER_CHAR_1 0x00
#define SERIAL_END_OF_BUFFER_CHAR_2 0x11
#define SERIAL_END_OF_BUFFER_CHAR_3 0x22
#define SERIAL_END_OF_BUFFER_CHAR_4 0x33

// 最大包大小
#define MaxSerialPacketSize         10 * 1024 * 1024  // 10MB

/**
 * @brief 初始化串口
 */
BOOLEAN SerialConnectionInitialize() {
    // 1. 禁用中断
    __outbyte(COM_PORT + 1, 0x00);

    // 2. 设置波特率
    // 设置DLAB=1以访问波特率寄存器
    __outbyte(COM_PORT + SERIAL_LCR_OFFSET, 0x80);

    // 设置divisor（115200 = 115200 / divisor）
    UINT16 Divisor = 1;  // 115200 baud
    __outbyte(COM_PORT + 0, Divisor & 0xFF);        // DLL
    __outbyte(COM_PORT + 1, (Divisor >> 8) & 0xFF); // DLM

    // 3. 设置数据格式：8N1（8位数据，无校验，1位停止位）
    __outbyte(COM_PORT + SERIAL_LCR_OFFSET, 0x03);

    // 4. 启用FIFO，清除缓冲区
    __outbyte(COM_PORT + 2, 0xC7);

    // 5. 设置Modem控制
    __outbyte(COM_PORT + SERIAL_MCR_OFFSET, 0x0B);

    LogInfo("Serial port initialized at COM%d, baud rate: %d",
            COM_PORT_NUMBER, SERIAL_BAUD_RATE);

    return TRUE;
}
```

---

## 4.4 主要通信函数

### 4.4.1 发送响应包

```c
/**
 * @brief 发送响应包到调试器
 *
 * @param PacketType 包类型
 * @param Response 响应动作
 * @param OptionalBuffer 可选数据
 * @param OptionalBufferLength 可选数据长度
 * @return BOOLEAN 成功返回TRUE
 */
BOOLEAN KdResponsePacketToDebugger(
    DEBUGGER_REMOTE_PACKET_TYPE             PacketType,
    DEBUGGER_REMOTE_PACKET_REQUESTED_ACTION Response,
    CHAR *                                  OptionalBuffer,
    UINT32                                  OptionalBufferLength
) {
    DEBUGGER_REMOTE_PACKET Packet = {0};
    BOOLEAN                Result = FALSE;

    //
    // ========================================
    // 1. 构建包头
    // ========================================
    //
    Packet.Indicator = INDICATOR_OF_HYPERDBG_PACKET;
    Packet.TypeOfThePacket = PacketType;
    Packet.RequestedActionOfThePacket = Response;

    //
    // ========================================
    // 2. 发送包头
    // ========================================
    //
    Result = SerialConnectionSendBuffer(
        (CHAR *)&Packet,
        sizeof(DEBUGGER_REMOTE_PACKET)
    );

    if (!Result) {
        LogError("Failed to send packet header");
        return FALSE;
    }

    //
    // ========================================
    // 3. 发送可选数据
    // ========================================
    //
    if (OptionalBuffer != NULL && OptionalBufferLength != 0) {
        Result = SerialConnectionSendBuffer(
            OptionalBuffer,
            OptionalBufferLength
        );

        if (!Result) {
            LogError("Failed to send optional buffer");
            return FALSE;
        }
    }

    return TRUE;
}
```

### 4.4.2 接收命令包

```c
/**
 * @brief 从调试器接收包
 *
 * @param TheActualPacket 输出：接收到的包
 * @param BufferLength 输出：接收到的长度
 * @return BOOLEAN 成功返回TRUE
 */
BOOLEAN KdReceivePacketFromDebuggee(
    CHAR *  TheActualPacket,
    UINT32 * BufferLength
) {
    UINT32 Length = 0;

    //
    // ========================================
    // 1. 接收数据
    // ========================================
    //
    if (!SerialConnectionRecvBuffer(TheActualPacket, &Length)) {
        LogError("Failed to receive packet");
        return FALSE;
    }

    //
    // ========================================
    // 2. 验证包头
    // ========================================
    //
    PDEBUGGER_REMOTE_PACKET Packet = (PDEBUGGER_REMOTE_PACKET)TheActualPacket;

    if (Packet->Indicator != INDICATOR_OF_HYPERDBG_PACKET) {
        LogError("Invalid packet indicator: %llx", Packet->Indicator);
        return FALSE;
    }

    // 检查包类型
    if (Packet->TypeOfThePacket != DEBUGGER_REMOTE_PACKET_TYPE_DEBUGGER_TO_DEBUGGEE) {
        LogError("Invalid packet type: %x", Packet->TypeOfThePacket);
        return FALSE;
    }

    //
    // ========================================
    // 3. 返回长度
    // ========================================
    //
    *BufferLength = Length;

    LogInfo("Received packet, action: %x, length: %d",
            Packet->RequestedActionOfThePacket, Length);

    return TRUE;
}
```

---

## 4.5 调试器主循环

### 4.5.1 调试器等待循环

**文件位置**：`hyperdbg/hyperkd/code/debugger/kernel-level/Kd.c`

```c
/**
 * @brief 处理断点和调试断点
 * @details 这是调试器的主循环，等待用户命令
 */
VOID KdHandleBreakpointAndDebugBreakpoints(
    PROCESSOR_DEBUGGING_STATE *       DbgState,
    DEBUGGEE_PAUSING_REASON           Reason,
    PDEBUGGER_TRIGGERED_EVENT_DETAILS EventDetails
) {
    CHAR                       TheActualPacket[MaxSerialPacketSize] = {0};
    UINT32                     LengthReceived = 0;
    PDEBUGGER_REMOTE_PACKET    TheActualPacketPointer = NULL;
    BOOLEAN                    EscapeFromTheLoop = FALSE;
    UINT32                     CoreId = DbgState->CoreId;

    //
    // ========================================
    // 1. 锁定该核心
    // ========================================
    //
    SpinlockLock(&DbgState->Lock);

    LogInfo("Core %d locked, waiting for debugger commands", CoreId);

    //
    // ========================================
    // 2. 向调试器发送"已暂停"消息
    // ========================================
    //
    KdSendPausedPacketToDebugger(CoreId, Reason, EventDetails);

    //
    // ========================================
    // 3. 主循环 - 等待调试器命令
    // ========================================
    //
    while (!EscapeFromTheLoop) {

        //
        // 接收命令包
        //
        if (!KdReceivePacketFromDebuggee(TheActualPacket, &LengthReceived)) {
            LogError("Failed to receive packet from debugger");
            continue;
        }

        TheActualPacketPointer = (PDEBUGGER_REMOTE_PACKET)TheActualPacket;

        //
        // ========================================
        // 根据命令类型处理
        // ========================================
        //
        switch (TheActualPacketPointer->RequestedActionOfThePacket) {

            //
            // ----------------------------------------
            // 继续执行（g命令）
            // ----------------------------------------
            //
            case DEBUGGER_REMOTE_PACKET_REQUESTED_ACTION_ON_VMX_ROOT_MODE_CONTINUE:
            {
                LogInfo("Debugger requested continue");

                // 继续执行并退出循环
                KdContinueDebuggee(
                    DbgState,
                    TRUE,  // 解锁核心
                    DEBUGGER_REMOTE_PACKET_REQUESTED_ACTION_NO_ACTION
                );

                EscapeFromTheLoop = TRUE;
                break;
            }

            //
            // ----------------------------------------
            // 单步执行（t命令）
            // ----------------------------------------
            //
            case DEBUGGER_REMOTE_PACKET_REQUESTED_ACTION_ON_VMX_ROOT_MODE_STEP:
            {
                LogInfo("Debugger requested step");

                // 设置MTF单步执行
                VmFuncSetMonitorTrapFlag(TRUE);
                DbgState->TracingMode = TRUE;

                // 继续执行并退出循环
                KdContinueDebuggee(
                    DbgState,
                    TRUE,
                    DEBUGGER_REMOTE_PACKET_REQUESTED_ACTION_NO_ACTION
                );

                EscapeFromTheLoop = TRUE;
                break;
            }

            //
            // ----------------------------------------
            // 读取寄存器（r命令）
            // ----------------------------------------
            //
            case DEBUGGER_REMOTE_PACKET_REQUESTED_ACTION_ON_VMX_ROOT_READ_REGISTERS:
            {
                GUEST_REGS * Regs = VmFuncGetGuestRegs(CoreId);

                // 发送寄存器值到调试器
                KdResponsePacketToDebugger(
                    DEBUGGER_REMOTE_PACKET_TYPE_DEBUGGEE_TO_DEBUGGER,
                    DEBUGGER_REMOTE_PACKET_REQUESTED_ACTION_DEBUGGEE_RESULT_OF_REGISTERS,
                    (CHAR *)Regs,
                    sizeof(GUEST_REGS)
                );

                // 不退出循环，继续等待命令
                break;
            }

            //
            // ----------------------------------------
            // 读取内存（db/dd/dq命令）
            // ----------------------------------------
            //
            case DEBUGGER_REMOTE_PACKET_REQUESTED_ACTION_ON_VMX_ROOT_READ_MEMORY:
            {
                PDEBUGGER_READ_MEMORY ReadMemRequest =
                    (PDEBUGGER_READ_MEMORY)(TheActualPacket + sizeof(DEBUGGER_REMOTE_PACKET));

                CHAR * MemoryBuffer = PlatformMemAllocateNonPagedPool(ReadMemRequest->Size);

                // 读取内存
                BOOLEAN Success = MemoryMapperReadMemorySafe(
                    ReadMemRequest->Address,
                    MemoryBuffer,
                    ReadMemRequest->Size,
                    ReadMemRequest->ProcessId
                );

                if (Success) {
                    // 发送内存内容到调试器
                    KdResponsePacketToDebugger(
                        DEBUGGER_REMOTE_PACKET_TYPE_DEBUGGEE_TO_DEBUGGER,
                        DEBUGGER_REMOTE_PACKET_REQUESTED_ACTION_DEBUGGEE_RESULT_OF_MEMORY,
                        MemoryBuffer,
                        ReadMemRequest->Size
                    );
                } else {
                    // 发送错误响应
                    KdSendErrorResponse();
                }

                PlatformMemFreePool(MemoryBuffer);
                break;
            }

            //
            // ----------------------------------------
            // 编辑内存（eb/ed/eq命令）
            // ----------------------------------------
            //
            case DEBUGGER_REMOTE_PACKET_REQUESTED_ACTION_ON_VMX_ROOT_EDIT_MEMORY:
            {
                PDEBUGGER_EDIT_MEMORY EditMemRequest =
                    (PDEBUGGER_EDIT_MEMORY)(TheActualPacket + sizeof(DEBUGGER_REMOTE_PACKET));

                // 写入内存
                BOOLEAN Success = MemoryMapperWriteMemorySafe(
                    EditMemRequest->Address,
                    &EditMemRequest->NewValue,
                    EditMemRequest->ByteSize,
                    EditMemRequest->ProcessId
                );

                // 发送结果
                EditMemRequest->Result = Success ? DEBUGGER_OPERATION_WAS_SUCCESSFUL
                                                  : DEBUGGER_ERROR_EDIT_MEMORY_STATUS_INVALID_ADDRESS_BASED_ON_CURRENT_PROCESS;

                KdResponsePacketToDebugger(
                    DEBUGGER_REMOTE_PACKET_TYPE_DEBUGGEE_TO_DEBUGGER,
                    DEBUGGER_REMOTE_PACKET_REQUESTED_ACTION_DEBUGGEE_RESULT_OF_EDIT_MEMORY,
                    (CHAR *)EditMemRequest,
                    sizeof(DEBUGGER_EDIT_MEMORY)
                );

                break;
            }

            //
            // ----------------------------------------
            // 设置断点（bp命令）
            // ----------------------------------------
            //
            case DEBUGGER_REMOTE_PACKET_REQUESTED_ACTION_ON_VMX_ROOT_BP:
            {
                PDEBUGGEE_BP_PACKET BpPacket =
                    (PDEBUGGEE_BP_PACKET)(TheActualPacket + sizeof(DEBUGGER_REMOTE_PACKET));

                // 添加断点
                BreakpointAddNew(BpPacket, FALSE);

                // 发送结果
                KdResponsePacketToDebugger(
                    DEBUGGER_REMOTE_PACKET_TYPE_DEBUGGEE_TO_DEBUGGER,
                    DEBUGGER_REMOTE_PACKET_REQUESTED_ACTION_DEBUGGEE_RESULT_OF_BP,
                    (CHAR *)BpPacket,
                    sizeof(DEBUGGEE_BP_PACKET)
                );

                break;
            }

            //
            // ----------------------------------------
            // 查询事件和修改事件
            // ----------------------------------------
            //
            case DEBUGGER_REMOTE_PACKET_REQUESTED_ACTION_ON_VMX_ROOT_QUERY_AND_MODIFY_EVENT:
            {
                PDEBUGGER_MODIFY_EVENTS QueryAndModifyEventPacket =
                    (PDEBUGGER_MODIFY_EVENTS)(TheActualPacket + sizeof(DEBUGGER_REMOTE_PACKET));

                // 执行查询/修改操作
                if (KdPerformEventQueryAndModification(QueryAndModifyEventPacket)) {
                    // 如果需要继续执行
                    KdContinueDebuggee(
                        DbgState,
                        TRUE,
                        DEBUGGER_REMOTE_PACKET_REQUESTED_ACTION_DEBUGGEE_RESULT_OF_QUERY_AND_MODIFY_EVENT
                    );
                    EscapeFromTheLoop = TRUE;
                } else {
                    // 发送查询结果
                    KdResponsePacketToDebugger(
                        DEBUGGER_REMOTE_PACKET_TYPE_DEBUGGEE_TO_DEBUGGER,
                        DEBUGGER_REMOTE_PACKET_REQUESTED_ACTION_DEBUGGEE_RESULT_OF_QUERY_AND_MODIFY_EVENT,
                        (CHAR *)QueryAndModifyEventPacket,
                        sizeof(DEBUGGER_MODIFY_EVENTS)
                    );
                }

                break;
            }

            //
            // ----------------------------------------
            // 脚本执行
            // ----------------------------------------
            //
            case DEBUGGER_REMOTE_PACKET_REQUESTED_ACTION_ON_VMX_ROOT_RUN_SCRIPT:
            {
                PDEBUGGEE_SCRIPT_PACKET ScriptPacket =
                    (PDEBUGGEE_SCRIPT_PACKET)(TheActualPacket + sizeof(DEBUGGER_REMOTE_PACKET));

                // 执行脚本
                ScriptEngineWrapperTestParser(
                    ScriptPacket->Script,
                    ScriptPacket->ScriptLength,
                    &ScriptPacket->Result
                );

                // 发送执行结果
                KdResponsePacketToDebugger(
                    DEBUGGER_REMOTE_PACKET_TYPE_DEBUGGEE_TO_DEBUGGER,
                    DEBUGGER_REMOTE_PACKET_REQUESTED_ACTION_DEBUGGEE_RESULT_OF_SCRIPT,
                    (CHAR *)ScriptPacket,
                    sizeof(DEBUGGEE_SCRIPT_PACKET)
                );

                break;
            }

            //
            // ----------------------------------------
            // 关闭并卸载调试器
            // ----------------------------------------
            //
            case DEBUGGER_REMOTE_PACKET_REQUESTED_ACTION_ON_VMX_ROOT_MODE_CLOSE_AND_UNLOAD_DEBUGGEE:
            {
                LogInfo("Debugger requested close and unload");

                // 设置卸载标志
                g_DebuggeeUnloadRequested = TRUE;

                // 继续执行
                KdContinueDebuggee(DbgState, TRUE, DEBUGGER_REMOTE_PACKET_REQUESTED_ACTION_NO_ACTION);

                EscapeFromTheLoop = TRUE;
                break;
            }

            //
            // ----------------------------------------
            // 未知命令
            // ----------------------------------------
            //
            default:
            {
                LogWarning("Unknown packet action: %x",
                          TheActualPacketPointer->RequestedActionOfThePacket);

                // 发送错误响应
                KdSendErrorResponse();
                break;
            }
        }
    }

    //
    // ========================================
    // 4. 解锁核心
    // ========================================
    //
    SpinlockUnlock(&DbgState->Lock);

    LogInfo("Core %d unlocked, resuming execution", CoreId);
}
```

### 4.5 发送"已暂停"通知

```c
/**
 * @brief 向调试器发送"已暂停"包
 */
VOID KdSendPausedPacketToDebugger(
    UINT32                            CoreId,
    DEBUGGEE_PAUSING_REASON           Reason,
    PDEBUGGER_TRIGGERED_EVENT_DETAILS EventDetails
) {
    DEBUGGEE_PAUSED_PACKET PausedPacket = {0};

    //
    // ========================================
    // 填充暂停包信息
    // ========================================
    //
    PausedPacket.PausingReason = Reason;
    PausedPacket.CurrentCore = CoreId;

    // 读取当前指令
    UINT64 GuestRip = VmFuncGetLastVmexitRip(CoreId);
    PausedPacket.Rip = GuestRip;

    // 读取寄存器
    PGUEST_REGS Regs = VmFuncGetGuestRegs(CoreId);
    RtlCopyMemory(&PausedPacket.Registers, Regs, sizeof(GUEST_REGS));

    // 读取指令内容
    MemoryMapperReadMemorySafe(
        GuestRip,
        PausedPacket.InstructionBytesOnRip,
        MAXIMUM_INSTR_SIZE,
        NULL
    );

    // 如果有事件详情
    if (EventDetails != NULL) {
        RtlCopyMemory(&PausedPacket.EventDetails, EventDetails,
                     sizeof(DEBUGGER_TRIGGERED_EVENT_DETAILS));
    }

    //
    // ========================================
    // 发送包到调试器
    // ========================================
    //
    KdResponsePacketToDebugger(
        DEBUGGER_REMOTE_PACKET_TYPE_DEBUGGEE_TO_DEBUGGER,
        DEBUGGER_REMOTE_PACKET_REQUESTED_ACTION_DEBUGGEE_PAUSED_AND_CURRENT_INSTRUCTION,
        (CHAR *)&PausedPacket,
        sizeof(DEBUGGEE_PAUSED_PACKET)
    );

    LogInfo("Sent paused notification to debugger");
}
```

---

## 4.6 特定命令的通信示例

### 4.6.1 读取内存命令

```
调试器端：
    用户输入：db fffff80012345678 L100
         ↓
    构建READ_MEMORY包：
        Address = 0xfffff80012345678
        Size = 0x100
        ProcessId = 0 (kernel)
         ↓
    发送到被调试机
         ↓

被调试机端：
    接收包
         ↓
    解析：DEBUGGER_REMOTE_PACKET_REQUESTED_ACTION_ON_VMX_ROOT_READ_MEMORY
         ↓
    ReadMemRequest = (PDEBUGGER_READ_MEMORY)(包 + sizeof(包头))
         ↓
    分配缓冲区：MemoryBuffer = alloc(ReadMemRequest->Size)
         ↓
    读取内存：MemoryMapperReadMemorySafe(
        ReadMemRequest->Address,
        MemoryBuffer,
        ReadMemRequest->Size,
        ReadMemRequest->ProcessId
    )
         ↓
    发送内存内容回调试器：
        KdResponsePacketToDebugger(
            ...,
            DEBUGGEE_RESULT_OF_MEMORY,
            MemoryBuffer,
            ReadMemRequest->Size
        )
         ↓

调试器端：
    接收内存内容
         ↓
    格式化显示：
        fffff800`12345678  48 8b 05 e1 2f 3d 00-4c 8b 1d da 2f 3d 00  H.../?=.L.../?=.
        fffff800`12345688  4c 8b 25 d3 2f 3d 00-4c 8b 2d cc 2f 3d 00  L.%./?=.L.-./?=.
        ...
```

### 4.6.2 设置断点命令

```
调试器端：
    用户输入：bp nt!NtCreateFile
         ↓
    解析符号：NtCreateFile -> 0xfffff80012345678
         ↓
    构建BP包：
        Address = 0xfffff80012345678
        ProcessId = 0
        ThreadId = 0
         ↓
    发送到被调试机
         ↓

被调试机端：
    接收包
         ↓
    解析：DEBUGGER_REMOTE_PACKET_REQUESTED_ACTION_ON_VMX_ROOT_BP
         ↓
    BpPacket = (PDEBUGGEE_BP_PACKET)(包 + sizeof(包头))
         ↓
    添加断点：BreakpointAddNew(BpPacket, FALSE)
         ↓
    BreakpointAddNew内部：
        1. 分配BREAKPOINT结构
        2. 读取原始字节
        3. 写入0xCC (INT3)
        4. 设置异常位图拦截#BP
        5. 添加到断点列表
         ↓
    发送结果回调试器：
        BpPacket->Result = DEBUGGER_OPERATION_WAS_SUCCESSFUL
        KdResponsePacketToDebugger(..., DEBUGGEE_RESULT_OF_BP, ...)
         ↓

调试器端：
    接收结果
         ↓
    显示：Breakpoint set at nt!NtCreateFile (0xfffff80012345678)
```

### 4.6.3 单步执行命令

```
调试器端：
    用户输入：t
         ↓
    发送STEP包到被调试机
         ↓

被调试机端：
    接收包
         ↓
    解析：DEBUGGER_REMOTE_PACKET_REQUESTED_ACTION_ON_VMX_ROOT_MODE_STEP
         ↓
    设置单步模式：
        VmFuncSetMonitorTrapFlag(TRUE)
        DbgState->TracingMode = TRUE
         ↓
    继续执行：KdContinueDebuggee()
         ↓
    Guest执行一条指令
         ↓
    MTF触发VM-Exit
         ↓
    MtfHandleVmexit()
         ↓
    调用回调：VmmCallbackRegisteredMtfHandler(CoreId)
         ↓
    KdHandleRegisteredMtfCallback()
         ↓
    TracingHandleMtf()
         ↓
    发送"已暂停"包到调试器（包含新的RIP、寄存器等）
         ↓

调试器端：
    接收"已暂停"包
         ↓
    显示：
        0: kd> t
        nt!NtCreateFile+0x5:
        fffff800`1234567d  mov rax, qword ptr [rbp+0x40]
         ↓
    等待下一个命令
```

---

## 4.7 日志传输机制

### 4.7.1 日志缓冲区架构

```
┌─────────────────────────────────────────────────────────┐
│              日志缓冲区系统                              │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  VMX Root模式缓冲区                                     │
│  ┌───────────────────────────────────────────────────┐  │
│  │  Regular Buffer                                   │  │
│  │  ┌─────────┬─────────┬─────────┬─────────┐       │  │
│  │  │ Packet1 │ Packet2 │ Packet3 │   ...   │       │  │
│  │  └─────────┴─────────┴─────────┴─────────┘       │  │
│  ├───────────────────────────────────────────────────┤  │
│  │  Priority Buffer                                  │  │
│  │  ┌─────────┬─────────┐                           │  │
│  │  │ Packet1 │ Packet2 │                           │  │
│  │  └─────────┴─────────┘                           │  │
│  └───────────────────────────────────────────────────┘  │
│                                                         │
│  VMX Non-Root模式缓冲区                                 │
│  ┌───────────────────────────────────────────────────┐  │
│  │  Regular Buffer                                   │  │
│  │  ┌─────────┬─────────┬─────────┬─────────┐       │  │
│  │  │ Packet1 │ Packet2 │ Packet3 │   ...   │       │  │
│  │  └─────────┴─────────┴─────────┴─────────┘       │  │
│  ├───────────────────────────────────────────────────┤  │
│  │  Priority Buffer                                  │  │
│  │  ┌─────────┬─────────┐                           │  │
│  │  │ Packet1 │ Packet2 │                           │  │
│  │  └─────────┴─────────┘                           │  │
│  └───────────────────────────────────────────────────┘  │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 4.7.2 日志回调实现

```c
//
// ========================================
// 回调1：准备并发送消息到队列
// ========================================
//

/**
 * @brief 格式化并发送日志消息
 */
BOOLEAN LogCallbackPrepareAndSendMessageToQueueWrapper(
    UINT32       OperationCode,
    BOOLEAN      IsImmediateMessage,
    BOOLEAN      ShowCurrentSystemTime,
    BOOLEAN      Priority,
    const char * Fmt,
    va_list      ArgList
) {
    CHAR TempMessage[PacketChunkSize];
    UINT32 Length;

    // 1. 格式化消息
    Length = vsprintf_s(TempMessage, PacketChunkSize, Fmt, ArgList);

    // 2. 添加时间戳（如果需要）
    if (ShowCurrentSystemTime) {
        // 添加时间戳前缀
    }

    // 3. 调用发送消息回调
    return LogCallbackSendMessageToQueue(
        OperationCode,
        IsImmediateMessage,
        TempMessage,
        Length,
        Priority
    );
}

//
// ========================================
// 回调2：发送消息到队列
// ========================================
//

/**
 * @brief 将消息放入队列
 */
BOOLEAN LogCallbackSendMessageToQueue(
    UINT32  OperationCode,
    BOOLEAN IsImmediateMessage,
    CHAR *  LogMessage,
    UINT32  BufferLen,
    BOOLEAN Priority
) {
    //
    // 检查是否应该立即发送
    //
    if (IsImmediateMessage || KdCheckImmediateMessagingMechanism(OperationCode)) {

        // 立即发送，不缓冲
        return KdLoggingResponsePacketToDebugger(
            LogMessage,
            BufferLen,
            OperationCode
        );
    }

    //
    // 放入缓冲区
    //
    LOG_BUFFER_INFORMATION * LogBuffer;

    if (VmFuncVmxGetCurrentExecutionMode()) {
        // VMX root模式缓冲区
        LogBuffer = &MessageBufferInformation[0];
    } else {
        // VMX non-root模式缓冲区
        LogBuffer = &MessageBufferInformation[1];
    }

    // 根据优先级选择缓冲区
    if (Priority) {
        return LogSendToPriorityBuffer(LogBuffer, LogMessage, BufferLen, OperationCode);
    } else {
        return LogSendToRegularBuffer(LogBuffer, LogMessage, BufferLen, OperationCode);
    }
}

//
// ========================================
// 回调3：发送二进制缓冲区
// ========================================
//

/**
 * @brief 发送二进制数据（如内存dump、寄存器等）
 */
BOOLEAN LogCallbackSendBuffer(
    UINT32  OperationCode,
    PVOID   Buffer,
    UINT32  BufferLength,
    BOOLEAN Priority
) {
    // 检查缓冲区大小
    if (BufferLength > PacketChunkSize) {
        LogError("Buffer too large: %d bytes", BufferLength);
        return FALSE;
    }

    // 发送到相应的缓冲区
    return LogCallbackSendMessageToQueue(
        OperationCode,
        FALSE,  // 不立即发送
        (CHAR *)Buffer,
        BufferLength,
        Priority
    );
}

//
// ========================================
// 回调4：检查缓冲区状态
// ========================================
//

/**
 * @brief 检查缓冲区是否已满
 */
BOOLEAN LogCallbackCheckIfBufferIsFull(BOOLEAN Priority) {
    LOG_BUFFER_INFORMATION * LogBuffer;

    // 选择缓冲区
    if (VmFuncVmxGetCurrentExecutionMode()) {
        LogBuffer = &MessageBufferInformation[0];  // VMX root
    } else {
        LogBuffer = &MessageBufferInformation[1];  // VMX non-root
    }

    // 检查相应的缓冲区
    if (Priority) {
        return LogBuffer->PriorityBufferIsFull;
    } else {
        return LogBuffer->RegularBufferIsFull;
    }
}
```

---

## 4.8 通信场景详解

### 4.8.1 场景1：断点命中通信流程

```c
/**
 * @brief 完整的断点命中通信流程
 */

// ============================================
// Step 1: Guest执行到断点
// ============================================
Guest执行到地址 0xfffff80012345678
    ↓
执行INT3 (0xCC)
    ↓
触发#BP异常
    ↓
VM-Exit (VMX_EXIT_REASON_EXCEPTION_OR_NMI)

// ============================================
// Step 2: hyperhv处理异常
// ============================================
VmxVmexitHandler()
    ↓
IdtEmulationHandleExceptionAndNmi()
    ↓
检测到Vector = EXCEPTION_VECTOR_BREAKPOINT
    ↓
调用：VmmCallbackHandleBreakpointException(CoreId)
    ↓
Wrapper调用：g_Callbacks.DebuggingCallbackHandleBreakpointException()

// ============================================
// Step 3: hyperkd处理断点
// ============================================
BreakpointHandleBreakpoints(CoreId)
    ↓
查找断点列表
    ↓
找到断点：Bp = FindBreakpoint(GuestRip - 1)
    ↓
调用：KdHandleBreakpointAndDebugBreakpoints(
    DbgState,
    DEBUGGEE_PAUSING_REASON_DEBUGGEE_SOFTWARE_BREAKPOINT_HIT,
    NULL
)

// ============================================
// Step 4: 暂停并通知调试器
// ============================================
KdHandleBreakpointAndDebugBreakpoints()
    ↓
1. 锁定核心：SpinlockLock(&DbgState->Lock)
    ↓
2. 暂停其他核心：KdBroadcastNmiToAllCores()
    ↓
3. 等待所有核心暂停：WaitForAllCoresLocked()
    ↓
4. 构建暂停包：
    PausedPacket.PausingReason = DEBUGGEE_PAUSING_REASON_DEBUGGEE_SOFTWARE_BREAKPOINT_HIT;
    PausedPacket.CurrentCore = CoreId;
    PausedPacket.Rip = GuestRip;
    RtlCopyMemory(&PausedPacket.Registers, Regs, ...);
    ↓
5. 发送到调试器：
    KdResponsePacketToDebugger(
        DEBUGGER_REMOTE_PACKET_TYPE_DEBUGGEE_TO_DEBUGGER,
        DEBUGGER_REMOTE_PACKET_REQUESTED_ACTION_DEBUGGEE_PAUSED_AND_CURRENT_INSTRUCTION,
        &PausedPacket,
        sizeof(DEBUGGEE_PAUSED_PACKET)
    )
    ↓
    SerialConnectionSendBuffer() // 串口发送
    ↓

// ============================================
// Step 5: 调试器显示
// ============================================
调试器接收暂停包
    ↓
解析包内容
    ↓
显示：
    Breakpoint hit at nt!NtCreateFile (0xfffff800`12345678)
    0: kd>
    rax=0000000000000001 rbx=0000000000000000 rcx=fffffa8012345678
    ...
    nt!NtCreateFile:
    fffff800`12345678  48 89 5c 24 08    mov qword ptr [rsp+8], rbx
    ↓
等待用户命令

// ============================================
// Step 6: 用户输入继续命令
// ============================================
用户输入：g
    ↓
调试器构建CONTINUE包
    ↓
发送到被调试机
    ↓

// ============================================
// Step 7: hyperkd继续执行
// ============================================
KdHandleBreakpointAndDebugBreakpoints()
    ↓
while循环接收到CONTINUE命令
    ↓
调用：KdContinueDebuggee(DbgState, TRUE, ...)
    ↓
KdContinueDebuggee()内部：
    1. 解锁所有核心
    2. 清除暂停标志
    3. 退出等待循环
    ↓
返回到IdtEmulationHandleExceptionAndNmi()
    ↓
返回到VmxVmexitHandler()
    ↓
VMRESUME返回Guest
    ↓
Guest从断点后继续执行
```

### 4.8.2 场景2：日志输出通信

```c
/**
 * @brief 日志消息的传输流程
 */

// ============================================
// VMM中记录日志
// ============================================
void SomeVmmFunction() {
    LogInfo("EPT Violation at GPA: %llx", GuestPhysicalAddr);
}

// LogInfo宏展开后调用：
LogCallbackPrepareAndSendMessageToQueueWrapper(
    OPERATION_LOG_INFO_MESSAGE,
    FALSE,      // 不是立即消息
    TRUE,       // 显示时间戳
    FALSE,      // 不是优先级消息
    "EPT Violation at GPA: %llx",
    ArgList
)
    ↓

// ============================================
// 格式化消息
// ============================================
LogCallbackPrepareAndSendMessageToQueueWrapper()
    ↓
vsprintf_s(TempMessage, ..., Fmt, ArgList)
    结果："EPT Violation at GPA: fffff80012345678"
    ↓

// ============================================
// 发送到队列
// ============================================
LogCallbackSendMessageToQueue(
    OPERATION_LOG_INFO_MESSAGE,
    FALSE,  // 不立即发送
    "EPT Violation at GPA: fffff80012345678",
    Length,
    FALSE   // 普通优先级
)
    ↓

// ============================================
// 检查是否应该立即发送
// ============================================
KdCheckImmediateMessagingMechanism(OPERATION_LOG_INFO_MESSAGE)
    返回：FALSE（普通日志可以缓冲）
    ↓

// ============================================
// 放入缓冲区
// ============================================
选择缓冲区（根据VMX模式）
    ↓
LogSendToRegularBuffer()
    ↓
将消息放入环形缓冲区
    ↓

// ============================================
// 批量发送（当缓冲区满或定时）
// ============================================
if (LogBuffer->RegularBufferIsFull) {
    // 通过串口批量发送缓冲区内容
    SerialConnectionSendBuffer(LogBuffer->Buffer, LogBuffer->CurrentPosition);

    // 清空缓冲区
    LogBuffer->CurrentPosition = 0;
    LogBuffer->RegularBufferIsFull = FALSE;
}
```

### 4.8.3 场景3：VMCALL传递数据

```c
/**
 * @brief 通过VMCALL从Guest向VMM传递数据
 */

// ============================================
// Guest端（如用户态程序）
// ============================================
void GuestFunction() {
    UINT64 Data = 0x12345678;

    // 执行VMCALL
    __vmx_vmcall(
        VMCALL_SEND_GENERAL_BUFFER_TO_DEBUGGER,  // VMCALL号
        (UINT64)&Data,                           // 参数1：数据地址
        sizeof(Data),                            // 参数2：数据大小
        0                                        // 参数3：保留
    );
}

// 实际的汇编实现
AsmVmxVmcall PROC
    mov rax, rcx        ; VMCALL号
    mov rdx, rdx        ; 参数1
    mov r8, r8          ; 参数2
    mov r9, r9          ; 参数3

    vmcall              ; 触发VM-Exit

    ret
AsmVmxVmcall ENDP

// ============================================
// VMM端处理VMCALL
// ============================================
VmxVmexitHandler()
    ↓
case VMX_EXIT_REASON_EXECUTE_VMCALL:
    VmxHandleVmcall(VCpu)

VmxHandleVmcall()
    ↓
读取VMCALL参数：
    VmcallNumber = VCpu->Regs->rcx;
    Param1 = VCpu->Regs->rdx;
    Param2 = VCpu->Regs->r8;
    Param3 = VCpu->Regs->r9;
    ↓
调用回调：
    VmmCallbackVmcallHandler(CoreId, VmcallNumber, Param1, Param2, Param3)

// ============================================
// hyperkd处理VMCALL
// ============================================
DebuggerVmcallHandler()
    ↓
switch (VmcallNumber) {
    case VMCALL_SEND_GENERAL_BUFFER_TO_DEBUGGER:
        {
            UINT64 DataAddress = OptionalParam1;
            UINT32 DataSize = OptionalParam2;

            // 分配缓冲区
            CHAR * Buffer = PlatformMemAllocateNonPagedPool(DataSize);

            // 从Guest地址空间读取数据
            MemoryMapperReadMemorySafe(
                DataAddress,
                Buffer,
                DataSize,
                PsGetCurrentProcessId()
            );

            // 发送到调试器
            LogCallbackSendBuffer(
                OPERATION_DEBUGGEE_SEND_GENERAL_BUFFER,
                Buffer,
                DataSize,
                FALSE
            );

            PlatformMemFreePool(Buffer);

            return TRUE;
        }
}
```

---

## 4.9 与外部调试器交互的关键回调

### 4.9.1 立即消息发送回调

```c
/**
 * @brief 这是与外部调试器直接通信的核心回调
 */
MsgTracingCallbacks.SendImmediateMessage = KdLoggingResponsePacketToDebugger;

/**
 * @brief 实现：发送立即消息到调试器
 */
BOOLEAN KdLoggingResponsePacketToDebugger(
    CHAR *  OptionalBuffer,
    UINT32  OptionalBufferLength,
    UINT32  OperationCode
) {
    DEBUGGER_REMOTE_PACKET Packet = {0};

    //
    // ========================================
    // 1. 构建数据包
    // ========================================
    //
    Packet.Indicator = INDICATOR_OF_HYPERDBG_PACKET;
    Packet.TypeOfThePacket = DEBUGGER_REMOTE_PACKET_TYPE_DEBUGGEE_TO_DEBUGGER;

    // 根据操作码设置动作
    switch (OperationCode) {
        case OPERATION_LOG_INFO_MESSAGE:
            Packet.RequestedActionOfThePacket =
                DEBUGGER_REMOTE_PACKET_REQUESTED_ACTION_DEBUGGEE_LOGGING_MESSAGE;
            break;

        case OPERATION_BREAKPOINT_HIT:
            Packet.RequestedActionOfThePacket =
                DEBUGGER_REMOTE_PACKET_REQUESTED_ACTION_DEBUGGEE_BREAKPOINT_HIT;
            break;

        // ... 其他操作码映射
    }

    //
    // ========================================
    // 2. 发送包头
    // ========================================
    //
    SerialConnectionSendBuffer((CHAR *)&Packet, sizeof(Packet));

    //
    // ========================================
    // 3. 发送数据
    // ========================================
    //
    if (OptionalBuffer && OptionalBufferLength > 0) {
        SerialConnectionSendBuffer(OptionalBuffer, OptionalBufferLength);
    }

    return TRUE;
}
```

### 4.9.2 命令执行完成通知

```c
/**
 * @brief 通知调试器命令执行完成
 */
VOID KdSendCommandFinishedSignal(UINT32 CoreId) {

    //
    // ========================================
    // 1. 暂停其他核心（如果需要）
    // ========================================
    //
    if (g_HaltOtherCoresAfterCommandFinished) {
        KdBroadcastNmiToAllCores();
        KdWaitForAllCoresLocked();
    }

    //
    // ========================================
    // 2. 发送完成信号
    // ========================================
    //
    KdResponsePacketToDebugger(
        DEBUGGER_REMOTE_PACKET_TYPE_DEBUGGEE_TO_DEBUGGER,
        DEBUGGER_REMOTE_PACKET_REQUESTED_ACTION_DEBUGGEE_COMMAND_FINISHED,
        NULL,
        0
    );

    //
    // ========================================
    // 3. 继续执行
    // ========================================
    //
    if (g_HaltOtherCoresAfterCommandFinished) {
        KdUnlockAllCores();
    }
}
```

### 4.9.3 格式化输出通信

```c
/**
 * @brief 发送格式化的输出到调试器
 * @details 如printf/print命令的结果
 */
VOID KdSendFormatPacketToDebugger(
    CHAR *  Format,
    UINT32  FormatLength,
    PVOID   VariablesList,
    UINT32  VariablesCount
) {
    DEBUGGEE_FORMATS_PACKET FormatsPacket = {0};

    //
    // ========================================
    // 1. 填充格式化包
    // ========================================
    //
    FormatsPacket.NumberOfVariables = VariablesCount;

    // 复制格式字符串
    RtlCopyMemory(FormatsPacket.Format, Format, FormatLength);

    // 复制变量值
    RtlCopyMemory(FormatsPacket.Variables, VariablesList,
                 VariablesCount * sizeof(UINT64));

    //
    // ========================================
    // 2. 发送到调试器
    // ========================================
    //
    KdResponsePacketToDebugger(
        DEBUGGER_REMOTE_PACKET_TYPE_DEBUGGEE_TO_DEBUGGER,
        DEBUGGER_REMOTE_PACKET_REQUESTED_ACTION_DEBUGGEE_RESULT_OF_FORMATS,
        (CHAR *)&FormatsPacket,
        sizeof(DEBUGGEE_FORMATS_PACKET)
    );

    //
    // 调试器端会：
    // 1. 接收包
    // 2. 解析格式字符串
    // 3. 使用变量值格式化输出
    // 4. 显示给用户
    //
}

// 使用示例：
// Guest脚本中：printf("Value: %d, Address: %llx", value, address);
// ↓
// 传递Format = "Value: %d, Address: %llx"
//       Variables = [value, address]
// ↓
// 调试器格式化后显示：Value: 123, Address: fffff80012345678
```

---

## 4.10 错误处理和重传机制

### 4.10.1 错误检测

```c
/**
 * @brief 发送错误响应到调试器
 */
VOID KdSendErrorResponse() {
    DEBUGGER_REMOTE_PACKET ErrorPacket = {0};

    ErrorPacket.Indicator = INDICATOR_OF_HYPERDBG_PACKET;
    ErrorPacket.TypeOfThePacket = DEBUGGER_REMOTE_PACKET_TYPE_DEBUGGEE_TO_DEBUGGER;
    ErrorPacket.RequestedActionOfThePacket =
        DEBUGGER_REMOTE_PACKET_REQUESTED_ACTION_DEBUGGEE_ERROR;

    SerialConnectionSendBuffer((CHAR *)&ErrorPacket, sizeof(ErrorPacket));
}

/**
 * @brief 校验包的完整性
 */
BOOLEAN KdValidatePacket(PDEBUGGER_REMOTE_PACKET Packet, UINT32 Length) {

    // 1. 检查包指示符
    if (Packet->Indicator != INDICATOR_OF_HYPERDBG_PACKET) {
        LogError("Invalid packet indicator");
        return FALSE;
    }

    // 2. 检查最小长度
    if (Length < sizeof(DEBUGGER_REMOTE_PACKET)) {
        LogError("Packet too small: %d bytes", Length);
        return FALSE;
    }

    // 3. 检查包类型
    if (Packet->TypeOfThePacket != DEBUGGER_REMOTE_PACKET_TYPE_DEBUGGER_TO_DEBUGGEE &&
        Packet->TypeOfThePacket != DEBUGGER_REMOTE_PACKET_TYPE_DEBUGGEE_TO_DEBUGGER) {
        LogError("Invalid packet type: %x", Packet->TypeOfThePacket);
        return FALSE;
    }

    return TRUE;
}
```

### 4.10.2 超时处理

```c
/**
 * @brief 带超时的接收
 */
BOOLEAN SerialConnectionRecvBufferWithTimeout(
    CHAR *  BufferToSave,
    UINT32 * LengthReceived,
    UINT32  TimeoutMs
) {
    LARGE_INTEGER StartTime, CurrentTime, Timeout;
    UINT32 Loop = 0;

    // 获取开始时间
    KeQuerySystemTime(&StartTime);
    Timeout.QuadPart = TimeoutMs * 10000LL;  // 转换为100纳秒单位

    while (TRUE) {
        UCHAR RecvChar;

        // 尝试接收
        if (KdHyperDbgRecvByte(&RecvChar)) {
            BufferToSave[Loop] = RecvChar;

            if (SerialConnectionCheckForTheEndOfTheBuffer(&Loop, (BYTE *)BufferToSave)) {
                *LengthReceived = Loop;
                return TRUE;
            }

            Loop++;
        }

        // 检查超时
        KeQuerySystemTime(&CurrentTime);
        if ((CurrentTime.QuadPart - StartTime.QuadPart) > Timeout.QuadPart) {
            LogError("Receive timeout after %d ms", TimeoutMs);
            return FALSE;
        }

        // 让出CPU
        _mm_pause();
    }
}
```

---

## 4.11 批量数据传输优化

### 4.11.1 分块传输

```c
/**
 * @brief 传输大块数据（如内存dump）
 */
BOOLEAN KdSendLargeBuffer(PVOID Buffer, UINT32 TotalSize) {
    UINT32 Offset = 0;
    UINT32 ChunkSize = MaxSerialPacketSize - sizeof(DEBUGGER_REMOTE_PACKET) - 100;

    while (Offset < TotalSize) {
        UINT32 RemainingSize = TotalSize - Offset;
        UINT32 CurrentChunkSize = (RemainingSize < ChunkSize) ? RemainingSize : ChunkSize;

        // 发送当前块
        DEBUGGER_REMOTE_PACKET Packet = {0};
        Packet.Indicator = INDICATOR_OF_HYPERDBG_PACKET;
        Packet.TypeOfThePacket = DEBUGGER_REMOTE_PACKET_TYPE_DEBUGGEE_TO_DEBUGGER;
        Packet.RequestedActionOfThePacket =
            DEBUGGER_REMOTE_PACKET_REQUESTED_ACTION_DEBUGGEE_RESULT_OF_MEMORY_CHUNK;

        // 发送包头
        SerialConnectionSendBuffer((CHAR *)&Packet, sizeof(Packet));

        // 发送数据块
        SerialConnectionSendBuffer(
            (CHAR *)Buffer + Offset,
            CurrentChunkSize
        );

        Offset += CurrentChunkSize;

        LogInfo("Sent chunk: offset=%d, size=%d, total=%d",
                Offset, CurrentChunkSize, TotalSize);
    }

    // 发送结束标记
    DEBUGGER_REMOTE_PACKET EndPacket = {0};
    EndPacket.Indicator = INDICATOR_OF_HYPERDBG_PACKET;
    EndPacket.TypeOfThePacket = DEBUGGER_REMOTE_PACKET_TYPE_DEBUGGEE_TO_DEBUGGER;
    EndPacket.RequestedActionOfThePacket =
        DEBUGGER_REMOTE_PACKET_REQUESTED_ACTION_DEBUGGEE_RESULT_OF_MEMORY_COMPLETE;

    SerialConnectionSendBuffer((CHAR *)&EndPacket, sizeof(EndPacket));

    return TRUE;
}
```

---

## 4.12 与外部调试器交互的完整示例

### 4.12.1 设置并命中断点的完整流程

```
┌─────────────────────────────────────────────────────────────────────┐
│                         调试器端                                     │
└─────────────────────────────────────────────────────────────────────┘

用户输入命令：
    0: kd> bp nt!NtCreateFile

调试器处理：
    1. 解析符号 "nt!NtCreateFile"
       ↓
    2. 查询符号服务器或本地符号
       结果：nt!NtCreateFile = 0xfffff800`12345678
       ↓
    3. 构建BP包：
       BpPacket.Address = 0xfffff80012345678
       BpPacket.ProcessId = 0  // kernel
       BpPacket.Pid = 0
       BpPacket.Tid = 0
       BpPacket.Core = -1  // all cores
       ↓
    4. 发送到被调试机：
       发送DEBUGGER_REMOTE_PACKET
       发送BpPacket
       ↓
       通过串口发送...

┌─────────────────────────────────────────────────────────────────────┐
│                         被调试机端                                   │
└─────────────────────────────────────────────────────────────────────┘

接收处理：
    1. SerialConnectionRecvBuffer()
       接收DEBUGGER_REMOTE_PACKET
       接收DEBUGGEE_BP_PACKET
       ↓
    2. 解析命令类型：
       DEBUGGER_REMOTE_PACKET_REQUESTED_ACTION_ON_VMX_ROOT_BP
       ↓
    3. 调用BreakpointAddNew()：
       ├─> 分配BREAKPOINT结构
       ├─> 读取原始字节：
       │   OriginalByte = *(BYTE*)0xfffff80012345678
       │   (假设是0x48)
       ├─> 写入INT3指令：
       │   *(BYTE*)0xfffff80012345678 = 0xCC
       ├─> 设置异常位图拦截#BP：
       │   VmFuncSetExceptionBitmap(CoreId, EXCEPTION_VECTOR_BREAKPOINT, TRUE)
       ├─> 添加到断点列表
       └─> 返回成功
       ↓
    4. 发送结果到调试器：
       BpPacket.Result = DEBUGGER_OPERATION_WAS_SUCCESSFUL
       KdResponsePacketToDebugger(
           DEBUGGER_REMOTE_PACKET_TYPE_DEBUGGEE_TO_DEBUGGER,
           DEBUGGER_REMOTE_PACKET_REQUESTED_ACTION_DEBUGGEE_RESULT_OF_BP,
           &BpPacket,
           sizeof(BpPacket)
       )
       ↓
       通过串口发送...

┌─────────────────────────────────────────────────────────────────────┐
│                         调试器端                                     │
└─────────────────────────────────────────────────────────────────────┘

接收结果：
    1. 接收响应包
       ↓
    2. 检查BpPacket.Result
       ↓
    3. 显示：
       0: kd> bp nt!NtCreateFile
       Breakpoint set successfully
       ↓
    4. 等待下一个命令

┌─────────────────────────────────────────────────────────────────────┐
│                  被调试机端 - Guest执行                              │
└─────────────────────────────────────────────────────────────────────┘

某个程序调用NtCreateFile：
    1. Guest执行到 0xfffff800`12345678
       ↓
    2. 执行INT3 (0xCC)
       ↓
    3. 触发#BP异常
       ↓
    4. VM-Exit (VMX_EXIT_REASON_EXCEPTION_OR_NMI)
       ↓
    5. VmxVmexitHandler()
       ├─> IdtEmulationHandleExceptionAndNmi()
       ├─> 检测到#BP
       ├─> VmmCallbackHandleBreakpointException(CoreId)
       └─> BreakpointHandleBreakpoints(CoreId)
           ├─> 查找断点列表
           ├─> 找到：Bp->Address = 0xfffff80012345678
           ├─> 调用KdHandleBreakpointAndDebugBreakpoints()
           └─> 进入调试器主循环

┌─────────────────────────────────────────────────────────────────────┐
│                         被调试机端 - 调试器循环                      │
└─────────────────────────────────────────────────────────────────────┘

KdHandleBreakpointAndDebugBreakpoints()：
    1. 锁定当前核心
       ↓
    2. 广播NMI到所有其他核心
       ↓
    3. 等待所有核心锁定
       ↓
    4. 构建"已暂停"包：
       PausedPacket.PausingReason = DEBUGGEE_PAUSING_REASON_DEBUGGEE_SOFTWARE_BREAKPOINT_HIT
       PausedPacket.CurrentCore = CoreId
       PausedPacket.Rip = 0xfffff80012345678
       复制寄存器...
       读取当前指令字节...
       ↓
    5. 发送到调试器：
       KdResponsePacketToDebugger(
           ...,
           DEBUGGEE_PAUSED_AND_CURRENT_INSTRUCTION,
           &PausedPacket,
           sizeof(PausedPacket)
       )
       ↓
       通过串口发送...

┌─────────────────────────────────────────────────────────────────────┐
│                         调试器端                                     │
└─────────────────────────────────────────────────────────────────────┘

接收暂停通知：
    1. 接收DEBUGGEE_PAUSED_PACKET
       ↓
    2. 解析内容
       ↓
    3. 显示：
       Breakpoint 0 hit
       nt!NtCreateFile:
       fffff800`12345678  48 8b 5c 24 08    mov rbx, qword ptr [rsp+8]

       0: kd>
       ↓
    4. 等待用户输入命令

用户输入：r
    ↓
    发送READ_REGISTERS命令
    ↓
    被调试机返回寄存器值
    ↓
    显示：
       rax=0000000000000001 rbx=0000000000000000 rcx=fffffa8012345678
       rdx=0000000000000020 rsi=0000000000000000 rdi=fffff80012340000
       ...

用户输入：g
    ↓
    发送CONTINUE命令
    ↓
    被调试机解锁所有核心
    ↓
    Guest继续执行
    ↓
    调试器显示：
       0: kd> g
```

---

## 4.13 通信性能优化

### 4.13.1 缓冲策略

```c
/**
 * @brief 智能缓冲策略
 */
BOOLEAN LogSendMessageWithBuffering(
    UINT32  OperationCode,
    CHAR *  Message,
    UINT32  Length,
    BOOLEAN Priority
) {
    //
    // ========================================
    // 立即发送的条件
    // ========================================
    //
    if (KdCheckImmediateMessagingMechanism(OperationCode) ||  // 操作码要求立即
        Priority ||                                            // 优先级消息
        VmFuncVmxGetCurrentExecutionMode()) {                 // 在VMX root模式

        // 立即发送，不缓冲
        return KdLoggingResponsePacketToDebugger(Message, Length, OperationCode);
    }

    //
    // ========================================
    // 尝试缓冲
    // ========================================
    //
    LOG_BUFFER_INFORMATION * LogBuffer = GetCurrentLogBuffer();

    // 检查缓冲区空间
    if (LogBuffer->CurrentPosition + Length > LogBuffer->BufferSize) {
        // 缓冲区满，先发送
        FlushLogBuffer(LogBuffer);
    }

    // 添加到缓冲区
    RtlCopyMemory(
        LogBuffer->Buffer + LogBuffer->CurrentPosition,
        Message,
        Length
    );

    LogBuffer->CurrentPosition += Length;
    LogBuffer->MessageCount++;

    // 如果达到一定数量，发送
    if (LogBuffer->MessageCount >= AUTO_FLUSH_THRESHOLD) {
        FlushLogBuffer(LogBuffer);
    }

    return TRUE;
}
```

### 4.13.2 批量发送

```c
/**
 * @brief 刷新日志缓冲区
 */
VOID FlushLogBuffer(LOG_BUFFER_INFORMATION * LogBuffer) {
    if (LogBuffer->CurrentPosition == 0) {
        // 空缓冲区
        return;
    }

    LogInfo("Flushing log buffer: %d messages, %d bytes",
            LogBuffer->MessageCount, LogBuffer->CurrentPosition);

    // 批量发送
    SerialConnectionSendBuffer(
        LogBuffer->Buffer,
        LogBuffer->CurrentPosition
    );

    // 重置缓冲区
    LogBuffer->CurrentPosition = 0;
    LogBuffer->MessageCount = 0;
}
```

---

## 本章小结

本章详细讲解了HyperDbg的调试器通信机制：

1. **通信架构**
   - 串口作为主要通信通道
   - 结构化数据包协议
   - 双向通信模型

2. **消息追踪回调**
   - VmxOperationCheck：检查VMX模式
   - CheckImmediateMessageSending：判断是否立即发送
   - SendImmediateMessage：立即消息传输

3. **串口通信层**
   - 字节级发送/接收
   - 包的开始/结束标记
   - 错误检测和处理

4. **数据包协议**
   - DEBUGGER_REMOTE_PACKET结构
   - 包类型和操作定义
   - 可选数据附加

5. **主要通信函数**
   - KdResponsePacketToDebugger：发送响应
   - KdReceivePacketFromDebuggee：接收命令
   - SerialConnectionSendBuffer/RecvBuffer：底层传输

6. **调试器主循环**
   - 断点命中后的等待循环
   - 命令接收和分发
   - 各种命令的处理（继续、单步、读写内存等）

7. **性能优化**
   - 日志缓冲机制
   - 立即消息vs批量消息
   - 大数据分块传输

通过这套通信机制，HyperDbg实现了与外部调试器的高效交互，支持完整的内核级调试功能。

---

[<< 上一章：VMM回调机制详解](./第三章-VMM回调机制详解.md) | [下一章：NMI广播与MTF机制 >>](./第五章-NMI广播与MTF机制.md)
